1. (v0.0.0) 无法支持多个CODEPART
问题追踪： gen_ll1_table.py中生成first集时，对A:=AB型文法处理有问题。
解决方法： 将直接结束改为跳过这个A。
是否解决： 是

2. (v0.0.0) parse的none处理问题
问题追踪： parcer.cpp里terminator条件
解决方法： 若terminator节点是<none>，就直接结束本轮循环，看下一个节点，不增加token计数
是否解决： 是

3. (v0.0.0) sentences_n无法匹配;
问题追踪： parcer.cpp里优先选择语法问题
解决方法： 将全部由终结符组成的语法设置为高优先级语法，优先判定
重要更新： 加入语法优先级系统
是否解决： 是

4. (v0.0.1) 代码末行//注释时scanner报错问题
问题追踪： scanner用'\n'判定一行//注释的结束，若没有换行则报错
解决方法： 若准备报错时发现已经到代码末尾则不报。
是否解决： 是

5.1. (v0.0.1) 变量定义时使用双目运算符表达式，进入死循环问题
问题举例： int i = 0+1;
问题追踪： LL(1)表内 (EXPR, <number>)格内只有规则66而没有别的规则
问题追踪： 生成first表时对60(EXPR := EXPR <opr_two> EXPR)处理有问题
问题追踪： 生成first集时，对A:=AB型文法处理，不应该直接跳过，而应该进行传染
解决方法： 对A:=AB型文法，使用传染算法
是否解决： 否

5.2. (v0.0.1) 变量定义时使用双目运算符表达式，进入死循环问题
问题举例： int i = 0+1;
问题追踪： 一直尝试递归使用三目运算解析而无法选择二目运算。
问题追踪： 在grammar.txt中，二目运算在先。但压栈后顺序颠倒。
解决方法： 压栈前先颠倒顺序，保证优先级顺序和grammar.txt的排列顺序相同。
是否解决： 否

5.3. (v0.0.1) 变量定义时使用双目运算符表达式，进入死循环问题
问题举例： int i = 0+1;
问题追踪： 仍然递归，只不过不是三目运算而是变成右单目运算了。
问题追踪： 右单目运算和双目运算，一个是A:=Ab|c，一个是A:=AbA|c
以A:=Ab|c举例。如果用该文法尝试匹配句子cd，在尝试过A:=c后，整句节点会尝试匹配A:=Ab【分支1】，
在这个过程中右侧第一个A会匹配A:=c【分支2】。接下来d和b发生终结符冲突，
此时分支2会回退，但分支1并不会。更进一步，分支2和分支1的选项是完全相同的，
因此分支2会选择A:=Ab进行下一个匹配。这时候分支2没有消失，并且又带来了，尝试匹配匹配A:=c的【分支3】……
因此，也就是说，左递归文法A:=Ax由于2步匹配的存在，只要进入匹配，就会一直尝试更深的匹配。
解决方法： **加入死循环检测**。死循环的特点是当前节点为终结符节点，父节点的语法为A:=Ab
当检测到死循环，一直退栈直到(退出来的状态对应的当前节点)是当前节点的父亲
重要更新： 加入无穷递归检测
是否解决： 是

6.1. (v0.0.2) 节点栈退出来的节点的父节点是nullptr
问题追踪： 当语法错误，需要AST还原时，删除节点包含了当前节点，导致该节点被置空
解决方法： 从当前节点后一个开始删除
是否解决： 不完全

6.2. (v0.0.2) 节点栈退出来的节点的父节点是nullptr
问题追踪： 当语法错误AST还原时，清除范围不应该是从当前节点之后，而是当前节点的最后一个兄弟节点之后。
解决方法： 从当前节点的最后一个兄弟节点的后一个开始删除
是否解决： 否

6.3. (v0.0.2) 节点栈退出来的节点的父节点是nullptr
问题追踪： 当语法错误AST还原时，保留的语法树的ID最大的节点不一定是当前节点的弟弟，而可以是它哥哥的孩子。
解决方法： 在状态中存档当时的树的大小，直接基于此大小还原。
是否解决： 是

7. (v0.0.2) 语法错误AST还原后，节点的child重复出现
问题追踪： 当语法错误AST还原时，不仅应该清除树中大于count的节点，也应该清除当前节点的children
解决方法： 当语法错误AST还原时，清除当前节点的children
是否解决： 是

8.1. (v0.0.2) 带减号表达式出现死循环
问题举例： int i = 7*2-2; 
问题追踪： scanner将运算符减号当成了负号，从而把它和后面的数字合并了
解决方法： 修改语法，将减号作为一个特殊的运算符，允许带减号数字
+ 修改符号表以及对应的列表长度
+ token.h的CUP_E_OPERATOR_TYPE增加新符号定义
+ 修改scanner.cpp/utils.cpp中符号判定代码
+ 验证scanner是否正常识别符号
+ 修改 grammar.txt ，增加新符号类别和新语法
+ 重新生成LL(1)表
+ 验证问题是否解决
是否解决： 否

8.2. (v0.0.2) 带减号表达式出现死循环
问题举例： int i = 7*2-2; 
问题追踪： vector terminaters定义时，两个字符串中间没有逗号，被当做了一个字符串
解决方法： 加上逗号
是否解决： 是

9. (v0.0.2) 变量定义语句后有其他语句时出现段错误
问题举例： float bb = 3.0; char ccc;
问题追踪： A:=AB型文法检测中，语法栈中可能不存在当前节点为父节点的栈帧
解决方法： 改为用节点高度判定何时停止pop
是否解决： 是 

10. (v0.0.2) 函数定义return语句无法被EXPR_N匹配
问题追踪： 关键字的tag和需求格式不符
解决方法： 使用一个map来记录关键字和tag（有<>）的对应关系
是否解决： 是

11. (v0.0.2) 第三句话是变量定义时陷入无穷递归
问题举例： int aaa; float bbb; char ccc = 1;
问题追踪： 当语法错误导致AST复原时，现有基于树节点的复原方案
只能剪掉语法栈帧的“当前节点”的子树，而忽略了其他节点下后于“当前节点”生成的子树 
解决方法： 仍旧采用基于nid的节点删除方案。
是否解决： 是

12.1. (v0.0.2) 调试出现段错误，node_stack弹出的节点被清除
问题追踪： 节点删除后有些被清理的孩子节点仍在孩子列表内
解决方法： 基于nid的节点删除结束后，需要额外清理一下当前节点的children
是否解决： 部分

12.2. (v0.0.2) 调试出现段错误，node_stack弹出的节点被清除
问题追踪： 某个被清理过节点的树节点有一个被清理的孩子残留
问题追踪： 基于nid的删除时，先delete了孩子，之后就无法根据nid判断是否从children列表中删除
解决方法： 两次遍历合并为一次，先清除再delete。
是否解决： 是

13. (v0.0.2) 括号表达式后有运算符时陷入死循环
问题举例： int i = (3-2)/4;
问题追踪： 无穷递归检测无法生效
解决方法： 增加了括号匹配和迭代处理
重要更新： 增加了括号匹配和迭代处理
是否解决： 是

14. (v0.0.3) 处理赋值语句出现无限循环
问题举例： j = j + 1;
问题追踪： 语法表中没有赋值语句
解决方法： 在语法表中增加赋值语句
是否解决： 是

15.1. (v0.0.3) 处理for语句出现死循环
问题举例： for(i=0; i<10;i++){ j += i; }
问题追踪： 语法表中没有赋值表达式
解决方法： 在for循环中允许赋值表达式
是否解决： 部分

15.2. (v0.0.3) 处理for语句出现死循环
问题举例： for(i=0; i<10;i++){ j += i; }
问题追踪： 语法表中右运算符的符号和utils提供的不符
解决方法： 统一符号
是否解决： 是

16.1 (v0.0.3) 处理switch语句出现死循环
问题追踪： LL(1)表中SENTENCE和<switch>项里竟然有 EXPR;
问题追踪： 生成LL(1)表的FOLLOW集部分条件判定错误，右端有非空终结符就不需要加入follow集。
解决方法： 重写判定条件
是否解决： 否

16.2 (v0.0.3) 处理switch语句出现死循环
问题追踪： 冒号没有被判定为terminator，之前删掉忘记加回来了
解决方法： 加回来
是否解决： 是

17. (v0.0.3) 函数调用在二目运算符/-左侧时，无法识别
问题举例： abs(k) > 0;
问题追踪： 为了避免死循环而设置的强制退栈条件退掉了正确答案
解决方法： 规定要在函数调用外加括号
是否解决： 否

18. (v0.0.3) 修剪树时发现，构造新节点后原树节点没有更新
问题追踪： 原节点的父节点就不是它的父节点
问题追踪： 树合并时，被合并节点的子节点的父节点没有置为新节点
解决方法： 合并时把被合并节点的子节点的父节点置为新节点
是否解决： 是

#########################################
# 编译器已知持基本语法，进入大版本v1.0
#########################################

重要更新：加入了一维数组支持

19. (v1.1.0) 标识符索引的数组元素赋值时，陷入无限循环
问题举例： a[n] = 0;
问题追踪： 赋值表达式语法没有允许标识符索引
解决方法： 修改赋值表达式语法，使其允许表达式索引
是否解决： 是 

20.1. (v1.1.0) 大于等于4个元素的逗号表达式无法识别
问题举例： int a[6] = { 1, 1, 4, 5 };
问题追踪： 无限递归检测强制退出了正确路径
解决方法： 增加出错类型系统，对于节点栈空类错误不予强制退出
是否解决： 否

20.2. (v1.1.0) 大于等于4个元素的逗号表达式无法识别
问题举例： int a[6] = { 1, 1, 4, 5 };
问题追踪： 无限递归检测强制退出了正确路径
解决方法： 修改语法，逗号表达式的元素若非数字必须加括号
是否解决： 是

21. (v1.1.0) 有三个及以上形参，第一个是数组时，进入死循环
问题举例：void func(int a[], int b, int c);
问题追踪： 无限递归检测强制退出了正确路径
解决方法： 修改语法，形参若出现数组必须加括号
是否解决： 是 

22. (v1.1.5) 函数调用内有标识符时无法识别
问题举例： sqrt(n);
问题追踪： 20.2中规定了逗号表达式非数字必须加括号
解决方法： 修改语法，逗号表达式的元素如果不是EXPR_，就必须加括号
是否解决： 是 

重要更新：加入了多维数组支持
